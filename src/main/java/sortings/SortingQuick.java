package sortings;

/*
Один из самых быстрых известных универсальных алгоритмов сортировки.
В среднем O(n log(n)) обменов при упорядочивании n элементов.
Выбирается элемент каким-либо образом. Существуют разные способы выбора элемента,
но алгоритм работает с любым выбранным элементом. Это может быть самый первый,
либо самый последний элемент массива, либо элемент где-то посередине.
Этот элемент называется опорным.

Элементы в подмассивах проверяем по порядку - в левом подмассиве сначала, в правом с конца.
Когда находим первый эл. из левого подмассива, который меньше опорного
 и первый эл из правого, который больше опорного - меняем их местами.
В итоге элементы меньше опорного оказываются слева от него, а элементы больше опорного — справа.
К подмассивам слева и справа от опорного применяются первые два шага,
если в этих подмассивах больше одного элемента. От выбора опорного элемента
 работоспособность алгоритма не ломается, но может ухудшаться или улучшаться
 производительность. Может выбираться первый элемент, или последний, или средний и т. д.

    Достаточно прост.
    Довольно быстр.
    Допускает распараллеливание, так как подмассивы могут сортироваться параллельно.
    Можно использовать для связанных списков.

Недостатки:

    При неудачных входных данных может дать до O(n²) по скорости (если исходный массив уже отсортирован)
    Если делать прямую реализацию с рекурсивными вызовами, то может привести к переполнению стека.
    Неустойчив, так как меняет порядок равных элементов.

*/
public class SortingQuick {


    public static void quickSort(int[] arr, int lowBase, int highBase) {
        if ((arr.length == 0) || (lowBase >= highBase)) {
            return; //завершить выполнение если длина массива равна 0 или уже нечего делить
        }

        int pivotPoint = (highBase + lowBase) / 2;
        int low = lowBase;
        int high = highBase;

//Когда левый маркер low окажется за правым маркером high это будет означать, что обмен закончен, слева от pivot меньшие значения, справа от pivot — большие значения.
        while (low < high) {
            // Двигаем левый маркер слева направо пока элемент меньше, чем pivot
            while (arr[low] < arr[pivotPoint]) {
                low++;
            }
            // Двигаем правый маркер, пока элемент больше, чем pivot
            while (arr[high] > arr[pivotPoint]) {
                high--;
            }
            if (low <= high) {
                int tmp = arr[low];
                arr[low] = arr[high];
                arr[high] = tmp;
            }
            // Сдвигаем маркеры, чтобы получить новые границы
            low++;
            high--;
        }
        // вызов рекурсии для сортировки левой и правой части
        //когда high станет равен нижней границе, т.е это массив из трех или 2-х эл., сначала high равен пивотe,
        //дальше мы сдвигаем маркер и он становится равен ниж. границе - мы выходим из рекурсии
        if (lowBase < high) {
            quickSort(arr, lowBase, low);
        }
        if (highBase > low) {
            quickSort(arr, highBase, high);
        }

    }
}

 /*
        public static void quickSort(int[] source, int leftBorder, int rightBorder) {
        int leftMarker = leftBorder;
        int rightMarker = rightBorder;
        int pivot = source[(leftMarker + rightMarker) / 2];
        do {
            // Двигаем левый маркер слева направо пока элемент меньше, чем pivot
            while (source[leftMarker] < pivot) {
                leftMarker++;
            }
            // Двигаем правый маркер, пока элемент больше, чем pivot
            while (source[rightMarker] > pivot) {
                rightMarker--;
            }
            // Проверим, не нужно обменять местами элементы, на которые указывают маркеры
            if (leftMarker <= rightMarker) {
                // Левый маркер будет меньше правого только если мы должны выполнить swap
                if (leftMarker < rightMarker) {
                    int tmp = source[leftMarker];
                    source[leftMarker] = source[rightMarker];
                    source[rightMarker] = tmp;
                }
                // Сдвигаем маркеры, чтобы получить новые границы
                leftMarker++;
                rightMarker--;
            }
        } while (leftMarker <= rightMarker);

        // Выполняем рекурсивно для частей
        if (leftMarker < rightBorder) {
            quickSort(source, leftMarker, rightBorder);
        }
        if (leftBorder < rightMarker) {
            quickSort(source, leftBorder, rightMarker);
        }
}

 Для входного массива int[] source выставляем два маркера, левый (L) и правый (R). При первом вызове они соответствуют началу и концу массива. Далее определяется опорный элемент, он же pivot. После этого наша задача — переместить значения, меньшие чем pivot, в левую от pivot часть, а большие — в правую. Для этого сначала двигаем указатель L, пока не найдём значение, большее чем pivot. Если меньше значения не нашли, то L совпадёт с pivot.

Потом двигаем указатель R пока не найдём меньшее, чем pivot значение. Если большее значение не нашли, то R совпадёт с pivot.

Далее, если указатель L находится до указателя R или совпадает с ним, то пытаемся выполнить обмен элементов, если элемент L меньше, чем R.

Далее L сдвигаем вправо на 1 позицию, R сдвигаем влево на одну позицию.

Когда левый маркер L окажется за правым маркером R это будет означать, что обмен закончен, слева от pivot меньшие значения, справа от pivot — большие значения.

После этого рекурсивно вызываем такую же сортировку для участков массива от начала сортируемого участка до правого маркера и от левого маркера до конца сортируемого участка.

Почему от начала до правого? Потому что в конце итерации так и получится, что правый маркер сдвинется настолько, что станет границей части слева.

Этот алгоритм более сложный, чем простая сортировка, поэтому его лучше зарисовать. Возьмём белый лист бумаги, запишем: 4 2 6 7 3 , а Pivot по центру, т.е. число 6. Обведём его в круг.

Под 4 напишем L, под 3 напишем R. 4 меньше чем 6, 2 меньше чем 6. Итого, L переместился на положение pivot, т.к. по условию L не может уйти дальше, чем pivot.

Напишем снова 4 2 6 7 3 , обведём 6 вкруг (pivot) и поставим под ним L. Теперь двигаем указатель R.

3 меньше чем 6, поэтому ставим маркер R на цифру 3. Так как 3 меньше, чем pivot 6 выполняем swap, т.е. обмен.

Запишем результат: 4 2 3 7 6 , обводим 6 вкруг, т.к. он по прежнему pivot.

Указатель L на цифре 3, указатель R на цифре 6. Мы помним, что двигаем указатели до тех пор, пока L не зайдём за R. L двигаем на следующую цифру.

Тут хочется разобрать два варианта: если бы предпоследняя цифра была 7 и если бы она была не 7, а 1.

Предпоследня цифра 1: Сдвинули указатель L на цифру 1, т.к. мы можем двигать L до тех пор, пока указатель L указывает на цифру, меньшую чем pivot. А вот R мы не можем сдвинуть с 6, т.к. R не мы можем двигать только если указатель R указывает на цифру, которая больше чем pivot. swap не делаем, т.к. 1 меньше 6. Записываем положение: 4 2 3 1 6, обводим pivot 6. L сдвигается на pivot и больше не двигается. R тоже не двигается. Обмен не производим. Сдвигаем L и R на одну позицию и подписываем цифру 1 маркером R, а L получается вне числа. Т.к. L вне числа — ничего не делаем, а вот часть 4 2 3 1 выписываем снова, т.к. это наша левая часть, меньшая, чем pivot 6. Выделяем новый pivot и начинаем всё снова )

Предпоследняя цифра 7: Сдвинули указать L на цифру 7, правый указатель не можем двигать, т.к. он уже указывает на pivot. т.к. 7 больше, чем pivot, то делаем swap. Запишем результат: 4 2 3 6 7, обводим 6 кружком, т.к. он pivot. Указатель L теперь сдвигается на цифру 7, а указатель R сдвигается на цифру 3. Часть от L до конца нет смысла сортировать, т.к. там всего 1 элемент, а вот часть от 4 до указателя R отправляем на сортировку. Выбираем pivot и начинаем всё снова )

Может на первый взгляд показаться, что если расставить много одинаковых с pivot значений, это сломает алгоритм, но это не так. Можно напридумывать каверзных вариантов и на бумажке убедиться, что всё правильно и подивиться, как такие простые действия предоставляют такой надёжный механизм. Единственный минус — такая сортировка не является стабильной. Т.к. при выполнении обмена одинаковые элементы могут поменять свой порядок, если один из них встретился до pivot до того, как другой элемент попал в часть до pivot при помощи обмена.

 */


